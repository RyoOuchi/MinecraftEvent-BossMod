# 📘 コードドキュメント

## 概要
この `Message` クラスは、ネットワーク通信におけるメッセージの構造を表現するデータクラスで、ヘッダー (`Header`) と本体 (`Body`) を組み合わせて一つのメッセージを扱います。主な役割は次の通りです。

- バイト列からメッセージを復元する際にヘッダーとボディを抽出する。
- 既存のヘッダーとボディから完全なメッセージを構築する。
- メッセージ内からヘッダーおよびボディを取り出すためのユーティリティを提供する。

このクラスは他のクラス (`Header`、`Body`) に依存しており、メッセージの解析と構築を簡易に行えるようにします。エラー処理はシンプルに設計されており、ボディタグが見つからない場合には空の `Body` を返します。

---

## 🌐 グローバル変数一覧
| 変数名 | 型 | 初期値 | 使用箇所 | 説明 |
|--------|----|--------|----------|------|
| `header` | `Header` | コンストラクタで設定 | 全メソッド | メッセージのヘッダー部を表す。コンストラクタで渡された `Header` オブジェクト、またはメッセージバイト列から抽出されたヘッダーを保持する。 |
| `body` | `Body` | コンストラクタで設定 | 全メソッド | メッセージのボディ部（ペイロード）を表す。コンストラクタで渡された `Body` オブジェクト、またはメッセージバイト列から抽出されたボディを保持する。 |

このクラスには静的フィールドやその他のグローバル変数は存在しません。

---

## 🧩 関数一覧

### コンストラクタ `Message(Header header, Body body)`
- **概要**: 既に存在するヘッダーとボディを受け取り、新しい `Message` インスタンスを生成します。
- **引数**:
    - `header`: メッセージヘッダー (`Header` オブジェクト)。
    - `body`: メッセージボディ (`Body` オブジェクト)。
- **処理内容**: 渡された `header` と `body` をそのままフィールドに代入します。入力値の妥当性チェックは行いません。
- **呼び出し元**: 他クラスがメッセージを生成する際に使用します。例えば送信側でヘッダーとボディを組み合わせる場合に利用されます。

### コンストラクタ `Message(byte[] messageBytes)`
- **概要**: バイト列からメッセージを復元し、ヘッダーとボディを抽出して新しい `Message` インスタンスを生成します。
- **引数**: `messageBytes` – メッセージ全体を含むバイト配列。
- **処理内容**:
    1. バイト配列を `String message = new String(messageBytes)` で UTF‑8 文字列に変換します。
    2. `extractHeader(message)` を呼び出してヘッダーを生成し、`header` フィールドに設定します。
    3. `extractBody(message)` を呼び出してボディを生成し、`body` フィールドに設定します。
- **呼び出し元**: ネットワークから受信した生のバイト列を `Message` に変換する際に使用されます。
- **エラー処理**: バイト配列が不正な形式であっても内部では例外をスローしません。ボディタグ `[BODY]|` が見つからない場合は空の `Body` を返します。

### `Header getHeader() -> Header`
- **概要**: メッセージのヘッダー部を返します。
- **戻り値**: `header` フィールドに保持されている `Header` オブジェクト。
- **呼び出し元**: メッセージを解析する側がヘッダー内容を参照する際に使用します。

### `Body getBody() -> Body`
- **概要**: メッセージのボディ部を返します。
- **戻り値**: `body` フィールドに保持されている `Body` オブジェクト。
- **呼び出し元**: メッセージを解析する側がペイロードを取得する際に使用します。

### `String constructMessage() -> String`
- **概要**: 内部のヘッダーとボディから完全なメッセージ文字列を構築します。ヘッダーとボディの間に改行 (`\n`) を挿入します。
- **戻り値**: `header.constructHeader() + "\n" + body.getBody()` – ヘッダーの文字列表現に改行とボディの内容を連結した文字列。
- **呼び出し元**: メッセージを送信する側が、組み立て済みの文字列をソケットなどに書き出す際に使用します。
- **注意点**: `Header.constructHeader()` と `Body.getBody()` の実装に依存しており、ヘッダーの末尾やボディの区切りを管理する責任はこれらのクラスにあります。

### `Header extractHeader(String message) -> Header`
- **概要**: 文字列化されたメッセージからヘッダー部分を抽出し、`Header` オブジェクトを生成します。
- **引数**: `message` – ヘッダーとボディが含まれる完全なメッセージ文字列。
- **戻り値**: 新しい `Header` オブジェクト（`new Header(message.getBytes())`）。この実装ではメッセージ全体をヘッダーのデータとして渡しており、ヘッダー区切りの解析は `Header` クラス側に委ねています。
- **呼び出し元**: バイト配列コンストラクタや他クラスがヘッダーを抽出する際に使用することができます。

### `Body extractBody(String input) -> Body`
- **概要**: 指定文字列からボディ部のみを抽出し、`Body` オブジェクトを生成します。
- **引数**: `input` – ヘッダーとボディを含む完全なメッセージ文字列。
- **処理内容**:
    1. ボディの開始タグ `[BODY]|` を検索し、その位置を `startIndex` に保存します。タグが見つからない場合は空の `Body` を返します。
    2. 開始タグ直後から次の区切り記号 `|` までの文字列をボディとして抽出します。この区切りが見つからない場合も空の `Body` を返します。
    3. 抽出した文字列を用いて `new Body()` を生成し返します。
- **戻り値**: 抽出した内容を保持する `Body` オブジェクト。開始タグや区切りが見つからない場合は内容が空のボディオブジェクトを返します。
- **呼び出し元**: バイト配列コンストラクタやメッセージ解析処理で使用されます。
- **エラー処理**: タグが存在しない、区切りが無い場合ともにエラーをスローせず空ボディを返すため、呼び出し側は空文字列を受け取ることになります。

---

## 🔁 呼び出し関係図（関数依存）
`Message` クラスのコンストラクタとメソッドの関係を示します。
```
Message(byte[] messageBytes)
├─ extractHeader(String message)
└─ extractBody(String message)

constructMessage()
├─ Header.constructHeader()   (外部クラス)
└─ Body.getBody()            (外部クラス)

extractBody(String input)
├─ new Body(String)          (外部クラス)
└─ return empty Body         (タグが無い場合)

extractHeader(String message)
└─ new Header(byte[])        (外部クラス)

getHeader(), getBody()
└─ return field
```
---

## ⚙️ 外部依存関係
| クラス／ライブラリ | 用途と理由 |
|------------------|-----------|
| **`Header`** | メッセージのヘッダー情報を保持し、ヘッダー文字列の構築 (`constructHeader()`) やシーケンス番号などの取得を担当します。`Message` クラスはヘッダー抽出と連結にこのクラスを利用します。 |
| **`Body`** | メッセージのペイロードを保持し、ボディ文字列の取得 (`getBody()`) やバイト配列化を担当します。`extractBody()` ではボディオブジェクトを生成します。 |
| **`String`**, **`byte[]`** | Java 標準クラス。メッセージの文字列表現とバイト表現の相互変換に使用します。 |
| **`[BODY]|` タグ** | メッセージ構造を区切るために使用する特殊タグ。`extractBody()` でタグを検索し、ボディ部分を判定します。 |

---

## 📄 ファイル別概要
| ファイル名／クラス名 | 主な責務 | 主な関数 |
|--------------------|-----------|-----------|
| **`Message.java`** | ヘッダーとボディからなるメッセージを表現するデータクラス。コンストラクタでメッセージの分解・組み立てを行い、ヘッダーやボディの取得、メッセージ文字列の構築を提供する。 | コンストラクタ群、`getHeader()`, `getBody()`, `constructMessage()`, `extractHeader()`, `extractBody()` |
| **`Header.java`** | メッセージヘッダーの解析と構築を行うクラス。シーケンス番号やACK番号の取得、ヘッダ文字列へのシリアライズなどの機能を提供する。 | `constructHeader()`, `getSeqNumber()`, `getAckNumber()` 等 |
| **`Body.java`** | メッセージボディのデータ保持と文字列化を行うクラス。ボディデータをバイト配列として保持し、文字列へ変換する機能を提供する。 | `getBody()`, `extractBody()` 等 |

---

## 💬 総評
`Message` クラスは、ネットワーク通信におけるヘッダーとボディの扱いをカプセル化し、メッセージの組み立てと分解を簡潔に行うためのユーティリティとして機能しています。第二コンストラクタではバイト列からヘッダーとボディを抽出する際に内部メソッドを利用し、エラーハンドリングを最小限に抑えています。ボディ区切りタグ `[BODY]|` が見つからない場合は空の `Body` を返すため、呼び出し側は空文字列を受け取り適切に処理する必要があります。

このクラス単体では例外処理や詳細なフォーマット検証を行わないため、上位層でのバリデーションが不可欠ですが、シンプルな設計により読みやすさと拡張性が保たれています。ヘッダーとボディを別クラスに分離することで責務が明確になっており、ネットワークプロトコルの実装において再利用可能な構造体として役立ちます。




# 📘 コードドキュメント

## 概要
`Body` クラスは、ネットワーク通信におけるメッセージのペイロード部分を表現するシンプルなデータクラスです。主な役割は以下の通りです。

- 与えられた文字列やバイト配列からボディを初期化し、必要であれば特定の形式（`[BODY]|...|`）でラップする。
- ボディデータを標準形式に変換するユーティリティを提供する (`constructBody()`).
- 格納されたボディから実際のデータ部分を抽出する (`extractBody()`).

このクラスはヘッダー部分を扱う `Header` クラスとは分離されており、ペイロードのラップ／アンラップのみを担当します。エラー処理は簡潔であり、無効な形式の場合は空文字を返す仕様になっています。

---

## 🌐 グローバル変数一覧
| 変数名 | 型 | 初期値 | 使用箇所 | 説明 |
|--------|----|--------|----------|------|
| `body` | `String` | コンストラクタで設定 | 全メソッド | ボディ部分を含む文字列。`[BODY]|` で始まり `|` で終わる形式か、コンストラクタで自動的にこの形式に変換された文字列を保持する。 |

このクラスにはその他の静的フィールドやグローバル変数は存在しません。

---

## 🧩 関数一覧

### コンストラクタ `Body(String body)`
- **概要**: 与えられた文字列をボディとして初期化します。必要であれば `[BODY]|...|` 形式に変換します。
- **引数**: `body` – ボディ内容を表す文字列。
- **処理内容**: `body` が `[BODY]|` で始まり `|` で終わる場合はそのままフィールドに設定。それ以外の場合は `constructBody(body)` を呼び出して形式変換した結果を `this.body` に設定します。
- **呼び出し元**: メッセージ送信側がペイロード文字列から `Body` オブジェクトを生成する際に使用します。
- **注意点**: 文字列が空や null であっても特に検証せず、そのままラップされます。

### コンストラクタ `Body(byte[] bodyBytes)`
- **概要**: バイト配列からボディを初期化します。
- **引数**: `bodyBytes` – ボディ内容を表すバイト配列。
- **処理内容**: `new String(bodyBytes)` で文字列に変換し、その文字列を使って再度 `new Body(bodyString)` を生成し、取得したボディ文字列 (`getBody()`) を `this.body` に設定します。このため、バイト配列でも適切に `[BODY]|...|` 形式に変換されます。
- **呼び出し元**: ネットワークから受信したボディデータを `Body` オブジェクトに変換する際に使用されます。

### `String constructBody(String body)`
- **概要**: 入力文字列を `[BODY]|...|` 形式にラップします。
- **引数**: `body` – ラップ対象となる文字列。
- **戻り値**: `"[BODY]|" + body + "|"` という形式の新しい文字列。
- **呼び出し元**: 文字列コンストラクタから、ラップが必要な場合に呼び出されます。直接ユーティリティとして使用することも可能です。

### `String getBody() -> String`
- **概要**: 格納されているボディ文字列全体を返します。
- **戻り値**: フィールド `body` に保持されている文字列（`[BODY]|` タグを含む場合はそのまま）。
- **呼び出し元**: メッセージの送信処理やログ出力など、ボディ全体を取得したい場面で使用されます。

### `String extractBody() -> String`
- **概要**: 格納されているボディから、実際の内容部分のみを取り出します。
- **処理内容**:
    1. `body` が null、`[BODY]|` で始まらない、または `|` で終わらない場合は空文字列 (`""`) を返します。
    2. 上記条件を満たしていれば、`body.substring(7, body.length() - 1)` を返します。ここで `7` は `[BODY]|` の長さに相当します。
- **戻り値**: ボディの実内容（タグを除いた部分）。無効な形式の場合は空文字列。
- **呼び出し元**: メッセージ受信処理やアプリケーションロジックでペイロードのみが必要な場合に使用されます。
- **エラー処理**: 無効な形式でも例外をスローせず空文字列を返すため、呼び出し側は空かどうかをチェックして処理すべきです。

---

## 🔁 呼び出し関係図（関数依存）
`Body` クラスのコンストラクタとメソッドの依存関係を以下に示します。
```
Body(String body)
├─ constructBody(String)   (必要に応じて)

Body(byte[] bodyBytes)
├─ new String(byte[])     (標準ライブラリ)
├─ new Body(String)       (再帰的に自クラスを利用)
└─ getBody()

extractBody()
└─ substring()            (Java 標準)

getBody()
└─ return field

constructBody()
└─ string concatenation
```

---

## ⚙️ 外部依存関係
| クラス／ライブラリ | 用途と理由 |
|------------------|-----------|
| **`String`** | Java 標準クラス。ボディの内容を表すために使用し、文字列操作に利用されます。|
| **`byte[]`** | バイト配列から文字列へ変換するために使用し、`Body(byte[] bodyBytes)` コンストラクタで利用されます。|
| **`[BODY]|` タグ** | ボディ文字列の開始と終了を区別するために使用される特殊フォーマット。`constructBody()` と `extractBody()` で処理の基準として利用されます。|

---

## 📄 ファイル別概要
| ファイル名／クラス名 | 主な責務 | 主な関数 |
|---------------------|------------|------------|
| **`Body.java`** | メッセージのペイロード部分を表すクラス。ボディ文字列のラッピング、取り出し、変換を担当する。 | コンストラクタ (`Body(String)`, `Body(byte[])`), `constructBody()`, `getBody()`, `extractBody()` |
| **`Message.java`** | メッセージ全体を構成するクラス。ヘッダーとボディを組み合わせ、メッセージの組み立て・解析を行う。 | コンストラクタ群、`getHeader()`, `getBody()`, `constructMessage()`, `extractHeader()`, `extractBody()` |
| **`Header.java`** | メッセージのヘッダー部分を解析・保持するクラス。 | `constructHeader()`, `getSeqNumber()`, `getAckNumber()` 等 |

---

## 💬 総評
`Body` クラスは非常にシンプルな構造であり、文字列やバイト配列からボディデータを `[BODY]|` 形式に統一し、内容の取得や抽出を容易にしています。`Body(String)` コンストラクタでは入力文字列が既にタグ付きかどうかを判定し、自動的にラッピングするため、呼び出し側はフォーマットを気にせずにペイロードを渡せます。また、`Body(byte[])` コンストラクタではバイト配列を一度文字列に変換してから再利用することで、コードの重複を避けています。

タグの検証は簡潔な条件式で行われており、不正な形式の場合は空文字列を返すことでエラーを表現します。このため、上位層でのバリデーションやエラーメッセージの補完が必要ですが、基礎的なボディ処理として十分機能します。ヘッダーとボディの責務が分離されていることで、ネットワークプロトコルの実装において役割が明確になっており、保守性が高い設計といえます。




# コードドキュメント

## 概要
この `Header` クラスは、ネットワーク通信で扱われるヘッダ情報を表現するデータ構造です。主な役割は、文字列またはバイト配列からヘッダ情報を解析・構築し、ヘッダ内部の各キーと値を取得できるようにすることです。ヘッダは、`"[HEADER]|"` で始まりキーと値を `,` 区切りで列挙した後、`"|"` で終わる形式を想定しています。

---

## グローバル変数一覧
このクラスは以下のインスタンスフィールドを保持します。静的なグローバル変数はありません。

| 変数名 | 型 | 初期値 | 使用箇所 | 説明 |
|--------|----|--------|----------|------|
| `header` | `String` | コンストラクタ引数より設定 | `constructHeader()`, `getHeader()`, `extractHeader()` | 生のヘッダ文字列。`"[HEADER]|SEQ=100,ACK=200|"`のような形式を保持する。 |
| `headerSections` | `Map<String, String>` | コンストラクタで解析 | 各種getter (`getSeqNumber()`, `getAckNumber()` など) | ヘッダ文字列を解析して得たキーと値の対応表。`"SEQ"` → `"100"` などを保持。nullになる可能性あり。 |

---

## 関数一覧

### コンストラクタ群
- **`Header(String header)`**  
  与えられた文字列をヘッダとして内部に保存し、`parseHeaderSections()` でキーと値のマップに変換します。
- **`Header(Map<String, String> headerSections)`**  
  与えられたキー・値マップからヘッダを構築し、文字列として `header` に設定します。
- **`Header(byte[] headerBytes)`**  
  バイト配列から文字列に変換し、`extractHeader()` でヘッダ部分を抽出して保存します。その後、`parseHeaderSections()` でマップに変換します。

### `String constructHeader()`
- ヘッダマップ (`headerSections`) からヘッダ文字列を生成します。形式は `"[HEADER]|key=value,key2=value2|"`。末尾の余分なカンマを削除してから終端の `"|"` を付加します。

### `@Nullable String extractHeader(String message)`
- メッセージ文字列全体から `"[HEADER]|"` から次の `"|"` までの部分を抽出します。見つからない場合は null を返します。

### `@Nullable Map<String, String> parseHeaderSections(@Nullable String header)`
- ヘッダ文字列内のキーと値を `,` 区切りで分割し、`"="` で再分割して `Map<String, String>` に格納します。ヘッダ文字列が null または空の場合は null を返します。

### `Map<String, String> getHeaderSections()`
- 解析済みのヘッダマップを返します。

### `String getHeader()`
- 保存されているヘッダ文字列を返します。

### 数値取得メソッド
- **`int getSeqNumber()`**  
  ヘッダマップから `"SEQ"` を整数として取得し、変換に失敗した場合は -1 を返します。
- **`int getAckNumber()`**  
  ヘッダマップから `"ACK"` を整数として取得し、変換に失敗した場合は -1 を返します。
- **`int getEndNumber()`**  
  ヘッダマップから `"END"` を整数として取得し、変換に失敗した場合は -1 を返します。
- **`int getResponseNumber()`**  
  ヘッダマップから `"RESPONSE"` を整数として取得し、変換に失敗した場合は -1 を返します。

各メソッドでは `NumberFormatException` を捕捉してログにエラーを出力し、-1 を返すことで例外発生を抑制します。

---

## 呼び出し関係図（関数依存）
```
Header(String header)
└─ parseHeaderSections(header)

Header(Map<String,String>)
└─ constructHeader()

Header(byte[] headerBytes)
├─ extractHeader(String)
└─ parseHeaderSections(String)

constructHeader()
└─ Iterates over headerSections

extractHeader()
└─ substring search

parseHeaderSections()
└─ split() & map population

getSeqNumber(), getAckNumber(), getEndNumber(), getResponseNumber()
└─ headerSections lookup & Integer.parseInt()
```
---

## 外部依存関係
| クラス／ライブラリ | 用途 |
|------------------|-----|
| **`java.util.Map`, `java.util.HashMap`** | ヘッダのキーと値を保持するために使用。 |
| **`javax.annotation.Nullable`** | null 許容な戻り値を示すアノテーション。 |
| **`String`, `StringBuilder`** | ヘッダ文字列の保持・構築に使用。 |
| **`Integer.parseInt()`** | ヘッダ値を整数に変換する際に使用。失敗時は例外を捕捉して -1 を返す。 |

---

## ファイル別概要
| ファイル名／クラス名 | 主な責務 | 主な関数 |
|--------------------|-----------|-----------|
| **`Header.java`** | ネットワークメッセージのヘッダを表現・解析・構築するクラス。 | コンストラクタ群、`constructHeader()`, `extractHeader()`, `parseHeaderSections()`, 数値取得メソッド等。 |